<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Grails Transactions - Revisited</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../../favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">@rpalcolea</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../../index.html">Home</a></li>
            <li><a href="../../about.html">About</a></li>
            <li><a href="../../feed.xml">Subscribe</a></li>
						<li><a href="https://github.com/rpalcolea" target="_blank"><i class="icon-2x icon-github"></i></a></li>
						<li><a href="https://twitter.com/rpalcolea" target="_blank"><i class="icon-2x icon-twitter"></i></a></li>
						<li><a href="https://www.linkedin.com/in/robertoperezalcolea" target="_blank"><i class="icon-2x icon-linkedin"></i></a></li>
				</ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
	
	<div class="page-header">
		<h1>Grails Transactions - Revisited</h1>
	</div>

	<p><em>17 January 2016</em></p>

	<p>
<p>As we know, Grails services by default have automatic transaction management such as propagation and so on. By setting transactional to false you disable automatic Spring managed transaction demarcation for every method in the service. When is set to the true, The propagation level of the transaction is by default PROPAGATION_REQUIRED. Also we can use the @ Transactional and @ NotTransactional annotations. </p>

<p>What is a transaction? In simple terms, a transaction is:</p>

<ul>
<li>getConnection()</li>
<li>setAutocommit(false)</li>
<li>do work</li>
<li>commit</li>
<li>Error handling and rollback if necessary</li>
</ul>

<p>But, what is happening in our database when we use transactions? The purpose of this post is to present some small code examples and the behavior at database level. There are some requirements for them to run the following examples:</p>

<ol>
<li>Create a grails applicaton (2.3+)</li>
<li>Configure the Datasource.groovy file to use a MySQL connnection.</li>
<li>Enable the query log for your MySQL server. <a href="http://stackoverflow.com/questions/6479107/how-to-enable-mysql-query-log">Here is a reference for that</a></li>
</ol>

<p>First, we can start creating a Domain Class and a Service to examine how a transaction works:</p>

<pre class="prettyprint">
<code>
class Person {
	String name
}

@Transactional
class PersonService {
	def save() {
		new Person(name: "Roberto").save()
		new Person(name: "Raj").save()
	}
}
</code>
</pre>

<p>Now, if we invoke the save method, we can see the following in our database log.</p>

<pre class="prettyprint">
<code>
140605  8:42:42    11 Query SET autocommit=0
11 Query insert into person (version, name) values (0, 'Roberto')
11 Query insert into person (version, name) values (0, 'Raj')
11 Query commit
11 Query SET autocommit=1
</code>
</pre>

<p>As you can see, is setting the autocommit to 0, inserting, commit, set autocommit 1. This is what we are expecting to do, this is the way we handle transactions.</p>

<p>Now let's see what happens when we add another method:</p>

<pre class="prettyprint">
<code>
@Transactional
class PersonService {

	def save() {
		new Person(name: "Roberto").save()
		new Person(name: "Raj").save()
		anotherSave()
	}

	def anotherSave() {
		new Person(name: "anotherPerson").save()
	}
}
</code>
</pre>

<p>If we invoke the save method again we will get this result:</p>

<pre class="prettyprint">
<code>
140605  8:48:58    11 Query SET autocommit=0
11 Query insert into person (version, name) values (0, 'Roberto')
11 Query insert into person (version, name) values (0, 'Raj')
11 Query insert into person (version, name) values (0, 'anotherPerson')
11 Query commit
11 Query SET autocommit=1
</code>
</pre>

<p>By default, the Grails transactions have REQUIRED propagation,  and in this case the 'anotherSave' method will join the current transaction.</p>

<p>But what if we need to run the 'anotherMethod' in another transaction? Well, we can just change the transaction's propagation to a REQUIRES_NEW. This will look like this:</p>

<pre class="prettyprint">
<code>
@Transactional
class PersonService {

	def save() {
		new Person(name: "Roberto").save()
		new Person(name: "Raj").save()
		anotherSave()
	}

	@Transactional(propagation = Propagation.REQUIRES_NEW)
	def anotherSave() {
		new Person(name: "anotherPerson").save()
	}
}
</code>
</pre>

<p>Again, we can invoke the save method and see the results:</p>

<pre class="prettyprint">
<code>
140605  8:58:41    11 Query SET autocommit=0
				11 Query insert into person (version, name) values (0, 'Roberto')
				11 Query insert into person (version, name) values (0, 'Raj')
				10 Query SET autocommit=0
				10 Query insert into person (version, name) values (0, 'anotherPerson')
				10 Query commit
				10 Query SET autocommit=1
				11 Query commit
				11 Query SET autocommit=1
</code>
</pre>

<p>At first glance we can see the change in autocommit but the most important thing are the numbers (10 and 11). These numbers represent the thread id, with this we know that they are running in another transaction.</p>

<p>Now, let's see what happens when a RuntimeException occurs in save method after invoking anotherSave. If you want, truncate our table after that, can change our code to this:</p>

<pre class="prettyprint">
<code>
@Transactional
class PersonService {

	def save() {
		new Person(name: "Roberto").save()
		new Person(name: "Raj").save()
		anotherSave()
		throw new RuntimeException("oh!")
	}

	@Transactional(propagation = Propagation.REQUIRES_NEW)
	def anotherSave() {
		new Person(name: "anotherPerson").save()
	}
}
</code>
</pre>

<p>If we invoke the save method we will get the following in our database log:</p>

<pre class="prettyprint">
<code>
140605  9:06:19    11 Query SET autocommit=0
				11 Query insert into person (version, name) values (0, 'Roberto')
				11 Query insert into person (version, name) values (0, 'Raj')
				10 Query SET autocommit=0
				10 Query insert into person (version, name) values (0, 'anotherPerson')
				10 Query commit
				10 Query SET autocommit=1
				11 Query rollback
				11 Query SET autocommit=1
</code>
</pre>

<p>Ok, we know we have two transactions, let's make query to the database.</p>

<pre class="prettyprint">
<code>
mysql&gt; select * from person;
+----+---------+---------------+
| id | version | name          |
+----+---------+---------------+
|  3 |       0 | anotherPerson |
+----+---------+---------------+
1 row in set (0.01 sec)

mysql&gt;
</code>
</pre>

<p>As you can see, we have a new record in our database, this was generated by the method anotherSave. This is because we are running this statement in another transaction. </p>

<p><strong>IMPORTANT: automatic rollback occurs if a method throws a runtime exception (i.e. one that extends RuntimeException) or an Error. Checked exceptions do not roll back transactions.</strong></p>

<p>Ok, by now you know that the transaction disables autocommit to execute one or more statements and then do the commit.</p>

<p>Now imagine a scenario in which you require that the  statements of anotherSave should be with auto-commit (MySQL has autocommit enabled by default). Let's take a look on this... first, we will put a few examples of possible ideas that won't work:</p>

<p><strong>FAIL: Using @NotTransactional annotation</strong></p>

<pre class="prettyprint">
<code>
@Transactional
class PersonService {

	def save() {
		new Person(name: "Roberto").save()
		anotherSave()
		new Person(name: "Raj").save()
	}

	@NotTransactional
	def anotherSave() {
		new Person(name: "anotherPerson").save()
	}
}
</code>
</pre>

<p>With this approach our database log will be:</p>

<pre class="prettyprint">
<code>
	140605  9:16:34    11 Query SET autocommit=0
				11 Query insert into person (version, name) values (0, 'Roberto')
				11 Query insert into person (version, name) values (0, 'anotherPerson')
				11 Query insert into person (version, name) values (0, 'Raj')
				11 Query commit
				11 Query SET autocommit=1
</code></pre>

<p>Look at this... is under the same thread. So this option is discarded.</p>

<p><strong>FAIL: Using Groovy SQL without change the propagation</strong></p>

<p>Well... maybe we can think something like "If MySQL sets autocommit by default we can use SQL with GroovySQL and done". The service can be like this:</p>

<pre class="prettyprint">
<code>
@Transactional
class PersonService {

	def save() {
		new Person(name: "Roberto").save()
		anotherSave()
		new Person(name: "Raj").save()
	}

	def sessionFactory

	def anotherSave() {
		def sql = new Sql(sessionFactory.currentSession.connection())
		sql.execute("INSERT INTO `test`.`person` (`version`, `name`) VALUES ('0', 'anotherPerson')")
	}

}
</code>
</pre>

<p>Ok... run this and you will see all in one transaction:</p>

<pre class="prettyprint">
<code>
140605  9:21:15    21 Query SET autocommit=0
				21 Query insert into person (version, name) values (0, 'Roberto')
				21 Query INSERT INTO `test`.`person` (`version`, `name`) VALUES ('0', 'anotherPerson')
				21 Query insert into person (version, name) values (0, 'Raj')
				21 Query commit
				21 Query SET autocommit=1
</code></pre>

<p>So this is not working as we expected... oh but maybe "we can just change the connection to autocommit".</p>

<p><strong>FAIL: Using Groovy SQL and change the connection to autocommit</strong></p>

<pre class="prettyprint">
<code>
@Transactional
class PersonService {

	def save() {
		new Person(name: "Roberto").save()
		anotherSave()
		new Person(name: "Raj").save()
	}

	def sessionFactory

	def anotherSave() {
		def sql = new Sql(sessionFactory.currentSession.connection())
		sql.connection.setAutoCommit(true)
		sql.execute("INSERT INTO `test`.`person` (`version`, `name`) VALUES ('0', 'anotherPerson')")
		sql.connection.setAutoCommit(false)
	}

}
</code>
</pre>

<p>Execute this and look:</p>

<pre class="prettyprint">
<code>
140605  9:22:47    21 Query SET autocommit=0
				21 Query insert into person (version, name) values (0, 'Roberto')
				21 Query SET autocommit=1
				21 Query INSERT INTO `test`.`person` (`version`, `name`) VALUES ('0', 'anotherPerson')
				21 Query SET autocommit=0
				21 Query insert into person (version, name) values (0, 'Raj')
				21 Query commit
				21 Query SET autocommit=1
</code></pre>

<p>Oh! is changing the autocommit but wait... is the same thread. What is happening with the first query. Of course this seems to be ok because we are inserting everything and the code is not throwing a RuntimeException or Error. Lets add a RuntimeException and run it again. For this, we will truncate our table.</p>

<pre class="prettyprint">
<code>
@Transactional
class PersonService {

	def save() {
		new Person(name: "Roberto").save()
		anotherSave()
		new Person(name: "Raj").save()
		throw new RuntimeException("Oh!")
	}

	def sessionFactory

	def anotherSave() {
		def sql = new Sql(sessionFactory.currentSession.connection())
		sql.connection.setAutoCommit(true)
		sql.execute("INSERT INTO `test`.`person` (`version`, `name`) VALUES ('0', 'anotherPerson')")
		sql.connection.setAutoCommit(false)
	}
}
</code></pre>

<p>Execute this and you will see the same query log but look at your table data:</p>

<pre class="prettyprint">
<code>
mysql&gt; select * from person;
+----+---------+---------------+
| id | version | name          |
+----+---------+---------------+
|  1 |       0 | Roberto       |
|  2 |       0 | anotherPerson |
+----+---------+---------------+
2 rows in set (0.00 sec)

mysql&gt;
</code>
</pre>

<p>Yes we set the autocommit to true but we were under the same transaction so our first query was commited too and we don't want this.</p>

<p>This is where we can use another propagation. Let's try it with NOT<em>SUPPORTED and use GORM again. NOT</em>SUPPORTED execute non-transactionally, suspend the current transaction if one exists.</p>

<p><strong>OK: Use NOT_SUPPORTED propagation</strong></p>

<pre class="prettyprint">
<code>
@Transactional
class PersonService {

	def save() {
		new Person(name: "Roberto").save()
		anotherSave()
		new Person(name: "Raj").save()
		throw new RuntimeException("Oh!")
	}

	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	def anotherSave() {
		new Person(name: "another Person").save()
	}
}
</code></pre>

<p>Let's try this piece of code. We will truncate our table before that. </p>

<pre class="prettyprint">
<code>
140605  9:29:14    21 Query SET autocommit=0
				21 Query insert into person (version, name) values (0, 'Roberto')
				20 Query insert into person (version, name) values (0, 'another Person')
				21 Query insert into person (version, name) values (0, 'Raj')
				21 Query rollback
				21 Query SET autocommit=1
</code></pre>

<p>Take a look on the thread ids, our another person statement is running in another thread and using the autocommit behaviour from MySQL. Now, look at our data</p>

<pre class="prettyprint">
<code>
mysql&gt; select * from person;
+----+---------+----------------+
| id | version | name           |
+----+---------+----------------+
|  2 |       0 | another Person |
+----+---------+----------------+
1 row in set (0.00 sec)

mysql&gt;
</code></pre>

<p>We only have the record that we want and because we had an exception, the transaction in the save method became a rollback. This is a nice approach. </p>

<p><strong>IMPORTANT: We know that maybe is not common to go under an auto-commit rule but you never know maybe tomorrow you will need it</strong></p>

<p>To finish this small post, here is a list of the available propagations:</p>

<ul>
<li>PROPAGATION_MANDATORY:  Support a current transaction; throw an exception if no current transaction exists.</li>
<li>PROPAGATION<em>NESTED: Execute within a nested transaction if a current transaction exists, behave like PROPAGATION</em>REQUIRED else.</li>
<li>PROPAGATION_NEVER: Do not support a current transaction; throw an exception if a current transaction exists.</li>
<li>PROPAGATION<em>NOT</em>SUPPORTED: Do not support a current transaction; rather always execute non-transactionally.</li>
<li>PROPAGATION_REQUIRED: Support a current transaction; create a new one if none exists.</li>
<li>PROPAGATION<em>REQUIRES</em>NEW: Create a new transaction, suspending the current transaction if one exists.</li>
<li>PROPAGATION_SUPPORTS: Support a current transaction; execute non-transactionally if none exists.</li>
</ul>

<p>we deal with important data to the business, so we must pay close attention to avoid any data loss problem while running transactions</p>

<p>These examples were developed along with Raj Govindarajan.</p>

<p>Hope this can help you in the future.</p>
</p>

	<hr />
	
		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2016 Roberto Perez Alcolea | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.4.0</a></p>
      </div>
    </div>
    FreeMarker template error (DEBUG mode; use RETHROW in production!):
The following has evaluated to null or missing:
==> post  [in template "footer.ftl" at line 10, column 7]

----
Tip: If the failing expression is known to be legally refer to something that's sometimes null or missing, either specify a default value like myOptionalVar!myDefault, or use <#if myOptionalVar??>when-present<#else>when-missing</#if>. (These only cover the last step of the expression; to cover the whole expression, use parenthesis: (myOptionalVar.foo)!myDefault, (myOptionalVar.foo)??
----

----
FTL stack trace ("~" means nesting-related):
	- Failed at: ${post.uri}  [in template "footer.ftl" at line 10, column 5]
	- Reached through: #include "footer.ftl"  [in template "post.ftl" at line 15, column 1]
----

Java stack trace (for programmers):
----
freemarker.core.InvalidReferenceException: [... Exception message was already printed; see it above ...]
	at freemarker.core.InvalidReferenceException.getInstance(InvalidReferenceException.java:131)
	at freemarker.core.UnexpectedTypeException.newDesciptionBuilder(UnexpectedTypeException.java:77)
	at freemarker.core.UnexpectedTypeException.<init>(UnexpectedTypeException.java:40)
	at freemarker.core.NonHashException.<init>(NonHashException.java:46)
	at freemarker.core.Dot._eval(Dot.java:45)
	at freemarker.core.Expression.eval(Expression.java:78)
	at freemarker.core.Expression.evalAndCoerceToString(Expression.java:82)
	at freemarker.core.DollarVariable.accept(DollarVariable.java:41)
	at freemarker.core.Environment.visit(Environment.java:324)
	at freemarker.core.MixedContent.accept(MixedContent.java:54)
	at freemarker.core.Environment.visit(Environment.java:324)
	at freemarker.core.Environment.include(Environment.java:2072)
	at freemarker.core.Include.accept(Include.java:167)
	at freemarker.core.Environment.visit(Environment.java:324)
	at freemarker.core.MixedContent.accept(MixedContent.java:54)
	at freemarker.core.Environment.visit(Environment.java:324)
	at freemarker.core.Environment.process(Environment.java:302)
	at freemarker.template.Template.process(Template.java:325)
	at org.jbake.template.FreemarkerTemplateEngine.renderDocument(FreemarkerTemplateEngine.java:66)
	at org.jbake.template.DelegatingTemplateEngine.renderDocument(DelegatingTemplateEngine.java:65)
	at org.jbake.app.Renderer.render(Renderer.java:89)
	at org.jbake.app.Oven.bake(Oven.java:157)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:384)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1019)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:69)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:158)
	at me.champeau.gradle.JBakeTask$_bake_closure1.doCall(JBakeTask.groovy:38)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1019)
	at groovy.lang.Closure.call(Closure.java:426)
	at groovy.lang.Closure.call(Closure.java:442)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.with(DefaultGroovyMethods.java:241)
	at org.codehaus.groovy.runtime.dgm$757.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:274)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:56)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at me.champeau.gradle.JBakeTask.bake(JBakeTask.groovy:35)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)
	at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.doExecute(AnnotationProcessingTaskFactory.java:227)
	at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:220)
	at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:209)
	at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:585)
	at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:568)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
	at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
	at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
	at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
	at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:52)
	at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
	at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
	at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
	at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:203)
	at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:185)
	at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:66)
	at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:50)
	at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:25)
	at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:110)
	at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:37)
	at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:37)
	at org.gradle.execution.DefaultBuildExecuter.access$000(DefaultBuildExecuter.java:23)
	at org.gradle.execution.DefaultBuildExecuter$1.proceed(DefaultBuildExecuter.java:43)
	at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
	at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:37)
	at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:30)
	at org.gradle.initialization.DefaultGradleLauncher$4.run(DefaultGradleLauncher.java:154)
	at org.gradle.internal.Factories$1.create(Factories.java:22)
	at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:90)
	at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:52)
	at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:151)
	at org.gradle.initialization.DefaultGradleLauncher.access$200(DefaultGradleLauncher.java:32)
	at org.gradle.initialization.DefaultGradleLauncher$1.create(DefaultGradleLauncher.java:99)
	at org.gradle.initialization.DefaultGradleLauncher$1.create(DefaultGradleLauncher.java:93)
	at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:90)
	at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:62)
	at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:93)
	at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:82)
	at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:94)
	at org.gradle.tooling.internal.provider.ExecuteBuildActionRunner.run(ExecuteBuildActionRunner.java:28)
	at org.gradle.launcher.exec.ChainingBuildActionRunner.run(ChainingBuildActionRunner.java:35)
	at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:43)
	at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:28)
	at org.gradle.launcher.exec.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:78)
	at org.gradle.launcher.exec.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:48)
	at org.gradle.launcher.exec.DaemonUsageSuggestingBuildActionExecuter.execute(DaemonUsageSuggestingBuildActionExecuter.java:51)
	at org.gradle.launcher.exec.DaemonUsageSuggestingBuildActionExecuter.execute(DaemonUsageSuggestingBuildActionExecuter.java:28)
	at org.gradle.launcher.cli.RunBuildAction.run(RunBuildAction.java:43)
	at org.gradle.internal.Actions$RunnableActionAdapter.execute(Actions.java:170)
	at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:237)
	at org.gradle.launcher.cli.CommandLineActionFactory$ParseAndBuildAction.execute(CommandLineActionFactory.java:210)
	at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:35)
	at org.gradle.launcher.cli.JavaRuntimeValidationAction.execute(JavaRuntimeValidationAction.java:24)
	at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:206)
	at org.gradle.launcher.cli.CommandLineActionFactory$WithLogging.execute(CommandLineActionFactory.java:169)
	at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:33)
	at org.gradle.launcher.cli.ExceptionReportingAction.execute(ExceptionReportingAction.java:22)
	at org.gradle.launcher.Main.doAction(Main.java:33)
	at org.gradle.launcher.bootstrap.EntryPoint.run(EntryPoint.java:45)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.launcher.bootstrap.ProcessBootstrap.runNoExit(ProcessBootstrap.java:54)
	at org.gradle.launcher.bootstrap.ProcessBootstrap.run(ProcessBootstrap.java:35)
	at org.gradle.launcher.GradleMain.main(GradleMain.java:23)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.wrapper.BootstrapMainStarter.start(BootstrapMainStarter.java:30)
	at org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:129)
	at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:61)
